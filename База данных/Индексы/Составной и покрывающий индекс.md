**Составной индекс** и **покрывающий индекс** — это два подхода к созданию индексов в базах данных, которые различаются по назначению и способу использования.

### 1. **Составной индекс (Composite Index)**
Составной индекс — это индекс, который включает более одного столбца таблицы. Он полезен для ускорения запросов, которые фильтруются по нескольким столбцам одновременно.

#### Пример:
```sql
CREATE INDEX idx_composite ON orders (customer_id, order_date);
```
Этот индекс может ускорить запросы, которые включают как `customer_id`, так и `order_date`, либо один из них (в зависимости от порядка).

#### Особенности:
- **Порядок полей важен**: Индекс работает эффективно, если фильтрация происходит сначала по первому столбцу, затем по следующему. Например, для индекса `(customer_id, order_date)` запрос по `customer_id` будет быстрым, но по одному только `order_date` индекс не будет использоваться эффективно.
  
- **Поддержка диапазонных запросов**: Составной индекс может быть полезен, если запросы включают диапазонные фильтры, такие как `BETWEEN`, `>`, `<` на одном из полей индекса.

#### Пример использования:
```sql
-- Этот запрос эффективно использует составной индекс
SELECT * FROM orders WHERE customer_id = 1 AND order_date = '2024-01-01';

-- Этот запрос также может использовать индекс
SELECT * FROM orders WHERE customer_id = 1;

-- Но запрос только по order_date не будет эффективно использовать индекс
SELECT * FROM orders WHERE order_date = '2024-01-01';
```

### 2. **Покрывающий индекс (Covering Index)**
Покрывающий индекс — это индекс, который содержит все столбцы, необходимые для выполнения запроса, включая столбцы в условиях фильтрации, сортировки и выборки данных. Он не только ускоряет поиск строк, но и позволяет базе данных получить все нужные данные непосредственно из индекса, не обращаясь к самой таблице.

#### Пример:
```sql
CREATE INDEX idx_covering ON orders (customer_id, order_date, total_amount);
```
Индекс включает все столбцы, которые могут быть использованы в `SELECT`, а значит, запрос может быть выполнен только за счет индекса без обращения к таблице.

#### Особенности:
- **Все данные находятся в индексе**: Покрывающий индекс содержит как ключевые столбцы для фильтрации, так и столбцы, которые запрашиваются в `SELECT`. Это позволяет системе избежать чтения данных из таблицы и выполнять запрос быстрее.
  
- **Ускорение за счет избежания чтения таблицы**: Если запрос выбирает только те столбцы, которые есть в индексе, база данных не будет обращаться к самой таблице (что известно как операция "Index Only Scan").

#### Пример использования:
```sql
-- Этот запрос полностью обслуживается покрывающим индексом, так как все необходимые столбцы есть в индексе
SELECT customer_id, order_date, total_amount
FROM orders
WHERE customer_id = 1 AND order_date = '2024-01-01';
```

### Сравнение составного и покрывающего индексов:

| Характеристика                     | Составной индекс                             | Покрывающий индекс                               |
|------------------------------------|----------------------------------------------|-------------------------------------------------|
| **Количество столбцов**            | Включает несколько столбцов для фильтрации   | Включает все столбцы, необходимые для выполнения запроса |
| **Использование**                  | Ускоряет запросы с фильтрацией по нескольким столбцам | Ускоряет запросы за счет исключения обращения к таблице |
| **Чтение данных из таблицы**       | Может потребовать чтения данных из таблицы   | Не требует чтения данных из таблицы, если все столбцы в индексе |
| **Эффективность для выборки**      | Эффективен для сложных условий фильтрации    | Эффективен для запросов, где все необходимые столбцы находятся в индексе |
| **Порядок полей**                  | Важно следить за порядком столбцов в индексе | Порядок столбцов не так важен, если запрос использует все нужные поля |

### Когда использовать:
- **Составной индекс** стоит использовать, если в запросах часто используются фильтры по нескольким столбцам.
- **Покрывающий индекс** стоит использовать, если нужно ускорить запросы, где выборка данных может происходить только из индекса, без необходимости обращаться к таблице.