**CQS (Command Query Separation)** и **CQRS (Command Query Responsibility Segregation)** — это два связанных, но разных подхода к организации архитектуры программных систем. Оба принципа помогают разделить команды (действия, изменяющие состояние системы) и запросы (операции, возвращающие данные), но их область применения и цели различаются. Рассмотрим различия между ними.

### 1. **CQS (Command Query Separation)**

**CQS** — это принцип проектирования кода, предложенный Бертраном Мейером. Основная идея заключается в том, что методы в системе должны быть либо **командами** (изменяющими состояние), либо **запросами** (возвращающими данные), но не тем и другим одновременно.

#### Основные характеристики CQS:

- **Простота**: CQS — это основной принцип проектирования кода и относится к методам одного объекта или класса.
- **Разделение операций**: Метод или функция либо изменяет состояние системы (команда), либо возвращает данные (запрос). Команда не должна возвращать данные, а запрос не должен изменять состояние.
- **Применение**: CQS чаще всего используется в классических объектно-ориентированных системах. Например, в ООП системе метод `updateProfile()` может изменить данные пользователя, но он не должен возвращать значения. А метод `getUserProfile()` должен только возвращать данные и не изменять их.

В данном случае методы разделены: один изменяет данные (команда), другой запрашивает информацию (запрос).

#### Преимущества CQS:

- **Упрощение тестирования**: Разделение команд и запросов делает код более предсказуемым и тестируемым.
- **Четкая логика**: Легче понимать, какие методы изменяют состояние системы, а какие нет.

---

### 2. **CQRS (Command Query Responsibility Segregation)**

**CQRS** — это более сложная архитектурная модель, основанная на расширении идеи CQS, которая разделяет **модель команд** и **модель запросов** на уровне архитектуры всей системы. В CQRS используются отдельные модели для чтения (запросов) и записи (команд), что даёт возможность оптимизировать их независимо друг от друга.

#### Основные характеристики CQRS:

- **Разделение моделей**: В отличие от CQS, где разделение происходит на уровне методов, CQRS разделяет модели данных и архитектуру. В системе может быть отдельная модель для чтения данных и отдельная модель для записи.
- **Оптимизация**: Так как запросы и команды обрабатываются разными моделями, каждая модель может быть оптимизирована для своей задачи. Например, модель чтения может быть организована для быстрой выборки данных, а модель записи — для безопасного и надёжного изменения данных.
- **Сложность**: CQRS добавляет сложности в архитектуру приложения, так как требует разделения логики на уровне данных, использования различных хранилищ (например, базы данных для чтения и для записи могут быть разными), и зачастую CQRS применяется в сочетании с **Event Sourcing** (источник событий).
  
#### Пример:

В простом CRUD-приложении можно было бы использовать одну модель для чтения и записи данных. Но при CQRS разделяются две модели:

- **Модель команд (Command Model)** — изменяет состояние системы (например, отправка команд на обновление данных).
- **Модель запросов (Query Model)** — извлекает и возвращает данные (оптимизированная для чтения).

#### Преимущества CQRS:

- **Масштабируемость**: CQRS позволяет масштабировать чтение и запись данных независимо. Например, можно масштабировать только запросы, если система испытывает большую нагрузку на чтение.
- **Производительность**: Возможность оптимизировать модели чтения и записи отдельно для повышения производительности.
- **Гибкость**: Поддержка различных подходов к обработке команд и запросов, использование различных баз данных для разных задач.

#### Пример сценария CQRS:

Предположим, есть система заказа товаров:

- **Команда (Command)**: Когда пользователь делает заказ, команда создаёт запись в базе данных заказов. При этом не требуется возвращать данные.
- **Запрос (Query)**: Когда пользователь хочет увидеть свои заказы, система использует другую модель, которая может извлекать данные быстрее, так как они могут быть специально оптимизированы для выборки (например, с использованием индексов или кэшей).

---

### Основные различия между CQS и CQRS

| **Характеристика**        | **CQS**                                     | **CQRS**                                          |
|---------------------------|---------------------------------------------|---------------------------------------------------|
| **Уровень применения**     | Принцип на уровне методов и классов         | Архитектурный паттерн на уровне всей системы      |
| **Разделение команд и запросов** | Разделение методов на команды и запросы  | Разделение моделей данных на команды и запросы    |
| **Сложность**              | Простой принцип для проектирования методов | Более сложный подход с разделением данных и логики|
| **Оптимизация**            | Методы не пересекаются, но данных это не касается | Модели чтения и записи данных могут быть оптимизированы отдельно |
| **Использование**          | Чаще всего в небольших и средних проектах   | Подходит для крупных систем с высокими нагрузками |
| **Связь с Event Sourcing** | Не используется                            | Часто применяется вместе с Event Sourcing         |

### Заключение

- **CQS** — это более простой принцип, который рекомендуется использовать для разделения логики на уровне методов.
- **CQRS** — это архитектурный подход, который подходит для более сложных систем, где требуется масштабируемость, производительность и чёткое разделение моделей для чтения и записи данных.

Оба подхода помогают сделать архитектуру более понятной и управляемой, но CQRS требует больше ресурсов для реализации и управления.