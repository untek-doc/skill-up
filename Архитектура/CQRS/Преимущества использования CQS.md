**CQS (Command Query Separation)**, или **Принцип разделения запросов и команд**, — это концепция, предложенная Бертраном Мейером. Она гласит, что метод в программе должен быть либо командой, которая изменяет состояние объекта, либо запросом, который возвращает данные, но не одновременно.

---

### **Преимущества использования CQS**

1. **Повышение читабельности кода**:
    
    - Код становится более понятным, так как чётко разделены действия, влияющие на состояние, и операции, возвращающие данные.
    
    Пример:
    
    ```php
    // Команда
    $order->completeOrder(); // Меняет состояние заказа.
    
    // Запрос
    $status = $order->getOrderStatus(); // Возвращает текущее состояние без изменения.
    ```
    
2. **Упрощение тестирования**:
    
    - Легче тестировать отдельные методы, поскольку они либо модифицируют состояние (команды), либо возвращают данные (запросы). Это снижает вероятность побочных эффектов.
3. **Чистота логики**:
    
    - Принцип позволяет избегать скрытых изменений состояния во время выполнения запросов, что делает поведение системы более предсказуемым.
4. **Облегчение поддержки и рефакторинга**:
    
    - Разделение операций упрощает идентификацию проблем и внесение изменений, так как каждая часть кода отвечает только за свою область.
5. **Улучшение многопоточности**:
    
    - Запросы не изменяют состояние, что позволяет безопасно выполнять их в многопоточном окружении. Это способствует параллелизму и потокобезопасности.
6. **Снижение побочных эффектов**:
    
    - Исключение методов, которые одновременно меняют состояние и возвращают данные, уменьшает вероятность возникновения неожиданных изменений в программе.
7. **Стабильность архитектуры**:
    
    - Применение CQS упрощает переход к более сложным архитектурным подходам, таким как CQRS (Command Query Responsibility Segregation), где команды и запросы обрабатываются разными слоями системы.
8. **Обеспечение прозрачности**:
    
    - Легче понять, что делает метод: изменяет состояние или возвращает данные. Это особенно полезно в больших системах.

---

### **Пример применения CQS в PHP**

```php
class User
{
    private string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    // Команда: изменяет состояние объекта
    public function changeName(string $newName): void
    {
        $this->name = $newName;
    }

    // Запрос: возвращает данные, но не изменяет состояние
    public function getName(): string
    {
        return $this->name;
    }
}

// Использование:
$user = new User('Alice');
echo $user->getName();    // Alice
$user->changeName('Bob');
echo $user->getName();    // Bob
```

---

### **Когда использовать CQS**

1. **В бизнес-логике**:
    
    - Помогает организовать чёткие границы между операциями, что особенно полезно в системах с высокой сложностью.
2. **При проектировании API**:
    
    - Обеспечивает интуитивно понятные интерфейсы для клиентов API.
3. **В многопользовательских приложениях**:
    
    - Упрощает обработку конкурентных запросов.
4. **В распределённых системах**:
    
    - CQS упрощает интеграцию с внешними системами, так как запросы не изменяют состояние, а команды гарантируют выполнение действий.

---

### **Недостатки CQS**

1. **Увеличение количества методов**:
    
    - Принцип может привести к большему числу методов в классах, так как команды и запросы разделяются.
2. **Потенциальная сложность в реализации**:
    
    - В некоторых случаях сложно полностью отделить команду от запроса (например, в методах с кэшированием).
3. **Дополнительные требования к дисциплине разработки**:
    
    - Для соблюдения CQS команда разработчиков должна строго придерживаться этого принципа, иначе его применение теряет смысл.

---

### **CQS и CQRS**

CQS можно рассматривать как базовый принцип, на основе которого строится CQRS (Command Query Responsibility Segregation). В CQRS команды и запросы обрабатываются разными слоями, что улучшает масштабируемость и производительность сложных систем.

---

### **Заключение**

Использование CQS позволяет улучшить структуру кода, упрощает тестирование и поддержку, делает систему более предсказуемой и безопасной. Несмотря на некоторые недостатки, этот принцип особенно полезен в сложных системах, где важна чёткая организация бизнес-логики и контроль за изменением состояния объектов.