### **Shared Kernel в контексте DDD**

**Shared Kernel** — это один из стратегических паттернов, описанных в **Domain-Driven Design (DDD)**, который используется для организации взаимодействия между несколькими **Bounded Contexts** (ограниченными контекстами). Он предполагает, что два или более контекста разделяют общую часть модели, которая строго определена и синхронизируется между ними.

---

### **Что такое Shared Kernel?**
Shared Kernel — это минимальный общий набор кода (обычно доменных объектов, значений или событий), используемый несколькими Bounded Contexts. Этот общий код должен быть тщательно управляем, чтобы минимизировать взаимозависимости и конфликты.

---

### **Когда использовать Shared Kernel?**
- Когда между контекстами существует сильная взаимосвязь, и их разделение на полностью независимые области нецелесообразно.
- Когда контексты принадлежат одной команде или группе, и можно обеспечить строгий контроль изменений в общем коде.
- Когда есть общие понятия, которые нецелесообразно дублировать, например, идентификаторы, общие доменные события или определение статусов.

---

### **Примеры использования**
1. **Общие типы данных**  
   Например, два контекста (заказы и инвентаризация) могут использовать общую сущность `Product`, которая определяет идентификатор продукта, название и базовые атрибуты.

2. **События домена**  
   Если несколько контекстов должны реагировать на одно событие, оно может быть определено в Shared Kernel.

3. **Управление доступом и пользователями**  
   Общая модель пользователя может использоваться между контекстами, связанными с аутентификацией и авторизацией.

---

### **Преимущества Shared Kernel**
1. **Снижение дублирования**  
   Позволяет избежать повторения кода и концепций в разных контекстах.

2. **Упрощённое взаимодействие**  
   Контексты могут легко интегрироваться за счёт использования общей модели.

3. **Общая терминология**  
   Гарантирует, что несколько контекстов используют единые определения для ключевых понятий.

---

### **Риски Shared Kernel**
1. **Повышенная связность**  
   Контексты становятся зависимыми от общего кода, что может усложнить их независимое развитие.

2. **Конфликты изменений**  
   Изменение Shared Kernel требует координации между командами, чтобы избежать неожиданных ошибок.

3. **Сложность управления**  
   Требуется строгий процесс контроля качества для внесения изменений в общий код.

---

### **Практическая реализация Shared Kernel**
#### 1. **Определите границы общего ядра**
Выделите только те элементы, которые действительно необходимы нескольким контекстам. Например:
- Базовые типы (идентификаторы, статусные перечисления).
- События, разделяемые несколькими контекстами.
- Общие сервисы, такие как преобразователи данных или валидаторы.

#### 2. **Изолируйте Shared Kernel**
Создайте отдельный модуль, библиотеку или пакет, который используется только контекстами, которым это нужно. Например:
- В **PHP** можно выделить Shared Kernel в отдельный пакет Composer.
- В **Java** это может быть отдельный модуль Maven.

#### 3. **Обеспечьте строгий контроль изменений**
Изменения в Shared Kernel должны проходить через процесс код-ревью, тестирования и согласования между всеми вовлечёнными командами.

#### 4. **Минимизируйте размер ядра**
Чем меньше общий код, тем проще его сопровождать и тем меньше рисков.

---

### **Пример на практике**

Допустим, у вас есть два контекста: **"Система управления заказами"** и **"Система управления инвентаризацией"**.

#### **Shared Kernel: Модель продукта**
```php
// SharedKernel/Product.php
namespace SharedKernel;

class Product
{
    private string $id;
    private string $name;

    public function __construct(string $id, string $name)
    {
        $this->id = $id;
        $this->name = $name;
    }

    public function getId(): string
    {
        return $this->id;
    }

    public function getName(): string
    {
        return $this->name;
    }
}
```

#### **Контекст заказов**
```php
// Orders/Order.php
namespace Orders;

use SharedKernel\Product;

class Order
{
    private Product $product;

    public function __construct(Product $product)
    {
        $this->product = $product;
    }

    public function getProduct(): Product
    {
        return $this->product;
    }
}
```

#### **Контекст инвентаризации**
```php
// Inventory/Stock.php
namespace Inventory;

use SharedKernel\Product;

class Stock
{
    private Product $product;
    private int $quantity;

    public function __construct(Product $product, int $quantity)
    {
        $this->product = $product;
        $this->quantity = $quantity;
    }

    public function getQuantity(): int
    {
        return $this->quantity;
    }
}
```

---

### **Альтернативы Shared Kernel**
Если Shared Kernel приводит к избыточной связанности, можно рассмотреть другие подходы:
- **Антипаттерн "Big Ball of Mud"** (не рекомендуется, если общее ядро слишком велико).
- **Взаимодействие через события**: контексты обмениваются сообщениями, избегая общей модели.
- **Open Host Service**: предоставление API для доступа к данным из других контекстов.

---

### **Вывод**
**Shared Kernel** — это мощный инструмент для разделения общих частей между контекстами, если они действительно нуждаются в разделении. Однако его использование требует строгого контроля, чтобы минимизировать риски связанности и конфликта изменений. Подходит для случаев, когда полное разделение контекстов невозможно или нецелесообразно.