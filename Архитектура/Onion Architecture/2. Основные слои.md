#### 1. **Core (ядро)**

Центр Onion Architecture состоит из двух ключевых элементов: **Entities (Сущности)** и **Interfaces (Интерфейсы)**. Это самые важные и стабильные части системы, которые не зависят ни от чего другого, кроме бизнес-логики.

**Entities (Сущности)**:
- Это центральные бизнес-объекты системы, которые представляют ключевые концепции и правила предметной области.
- Пример: классы, представляющие модель данных, с полями и методами, описывающими поведение бизнес-объекта.

**Interfaces (Интерфейсы)**:
- Это абстракции для взаимодействия с внешними компонентами (например, репозитории, сервисы).
- Они помогают изолировать внутреннюю логику от конкретных реализаций или технологий.
#### 2. **Application Services (Сервисный слой приложения)**

Этот слой реализует **бизнес-правила** и **логику работы** системы. Слой приложения отвечает за выполнение бизнес-функций, но **не знает** о том, как данные сохраняются или как с ними взаимодействуют конкретные интерфейсы (репозитории, внешние API и т.д.).

**Use Cases (Сценарии использования)**:
- Описывают последовательность действий для выполнения конкретных бизнес-задач.
- Пример: сценарий добавления нового пользователя в систему или обработка заказа.

**Services (Сервисы)**:
- Это классы, которые отвечают за координацию и управление бизнес-логикой.
- Эти сервисы вызывают методы сущностей и взаимодействуют с интерфейсами для выполнения операций.

#### 3. **Infrastructure (Инфраструктура)**

Это слой, который предоставляет **внешние зависимости** для системы. Здесь находятся конкретные реализации интерфейсов из Core, которые взаимодействуют с базой данных, внешними сервисами, файловой системой и другими системами.

**Repositories (Репозитории)**:
- Реализация интерфейсов для взаимодействия с базой данных.
- Пример: класс, который реализует репозиторий для сохранения данных сущностей в базу данных (например, через ORM).

**External Services (Внешние сервисы)**:
- Классы, которые реализуют взаимодействие с внешними API, мессенджерами, очередями сообщений и т.д.
- Пример: класс для взаимодействия с платежной системой или отправки писем по электронной почте.

#### 4. **UI/Presentation (Интерфейс пользователя/Представление)**

Этот слой находится на самой внешней части Onion Architecture и является **точкой входа в систему**. Он отвечает за представление данных и взаимодействие пользователя с приложением. Логика на этом уровне **не должна содержать бизнес-правил** и быть полностью изолированной от Core и Application Services.

**Controllers (Контроллеры)**:
- Веб-контроллеры или API-контроллеры, которые получают запросы от клиента и вызывают сервисы для выполнения бизнес-логики.

**ViewModels (Модели представления)**:
- Данные, которые преобразуются в удобный формат для отображения в пользовательском интерфейсе.

**UI (Пользовательский интерфейс)**:
- Это конкретная реализация пользовательского интерфейса — это может быть HTML/CSS, JavaScript, мобильное приложение или другие способы взаимодействия.

### Принципы Onion Architecture

1. **Зависимости направлены внутрь**:
Внутренние слои (Core, Application) не зависят от внешних слоев (UI, Infrastructure). Внешние слои могут зависеть от внутренних, но не наоборот.

2. **Изоляция бизнес-логики**:
Вся бизнес-логика сосредоточена в центре архитектуры, изолирована от внешних фреймворков и инфраструктурных деталей.

3. **Интерфейсы и абстракции**:
Взаимодействие с внешними компонентами (базы данных, API) осуществляется через абстракции (интерфейсы), которые описываются на уровне Core.

4. **Тестируемость**:
Поскольку бизнес-логика изолирована от внешних зависимостей, её легко тестировать с использованием mock или stub реализаций.

### Пример работы Onion Architecture

1. Пользователь отправляет запрос через UI (например, добавление нового заказа).
2. Контроллер в Presentation Layer принимает этот запрос и передает его на уровень Application Services.
3. Application Layer выполняет бизнес-логику (например, проверяет валидность данных, создаёт новый заказ).
4. Для взаимодействия с базой данных Application Layer использует абстракции (интерфейсы), не зная о том, как именно данные будут сохранены.
5. Реализация интерфейсов происходит в слое Infrastructure, где данные записываются в базу данных.
6. Результат возвращается обратно в UI для отображения пользователю.
