**Framework agnostic** (независимый от фреймворка) — это подход к разработке программного обеспечения, при котором код и архитектура системы не зависят от конкретного фреймворка. Это означает, что система разрабатывается таким образом, чтобы её основные компоненты (бизнес-логика, модели, обработчики данных и т. д.) могли быть легко перенесены или адаптированы для работы с любым фреймворком или средой.

---

### **Принципы Framework Agnostic разработки**

1. **Чёткое разделение бизнес-логики и инфраструктуры**
   - Основная логика приложения (например, обработка данных, выполнение операций) отделяется от конкретного фреймворка. Это делает систему менее зависимой от используемых библиотек и инструментов.

2. **Использование интерфейсов и абстракций**
   - Интерфейсы позволяют абстрагировать взаимодействие с конкретными компонентами фреймворка, такими как базы данных, системы маршрутизации или обработка HTTP-запросов.

3. **Слабая связанность (Low Coupling)**
   - Компоненты системы проектируются так, чтобы они могли работать независимо друг от друга. Это достигается через использование зависимостей, которые внедряются через DI-контейнеры (Dependency Injection).

4. **Сосредоточение на стандартных библиотеках**
   - Разработчики стремятся использовать стандартные функции языка программирования или сторонние библиотеки, которые не привязаны к конкретному фреймворку.

5. **Изолированное тестирование**
   - Код проектируется так, чтобы его можно было тестировать без необходимости загружать весь фреймворк или окружение.

---

### **Преимущества подхода**

1. **Легкость миграции**
   - Проект можно перенести с одного фреймворка на другой (например, с Laravel на Symfony или с Express.js на Koa) с минимальными изменениями в бизнес-логике.

2. **Повышенная гибкость**
   - Можно комбинировать различные инструменты и подходы, выбирая лучшие решения для каждой части системы.

3. **Упрощенное тестирование**
   - Тесты можно писать для отдельных модулей, не завися от инфраструктурных решений.

4. **Долговечность кода**
   - Если фреймворк устареет или станет больше не поддерживаться, бизнес-логика приложения останется актуальной и пригодной для использования с новыми технологиями.

5. **Переиспользование компонентов**
   - Логика, не зависящая от фреймворка, может быть использована в других проектах.

---

### **Недостатки подхода**

1. **Сложность реализации**
   - Разработка "framework agnostic" приложений требует большего уровня абстракции и навыков у команды разработчиков.

2. **Потенциальное увеличение объема кода**
   - Для поддержки независимости может понадобиться написать дополнительные слои абстракции.

3. **Снижение скорости разработки**
   - Использование фреймворк-специфичных возможностей может ускорить разработку, а отказ от них требует больше времени.

4. **Необходимость внедрения собственной инфраструктуры**
   - В некоторых случаях придется реализовать те механизмы, которые обычно предоставляет фреймворк (например, маршрутизацию, обработку запросов и т. д.).

---

### **Примеры применения**

1. **Бизнес-логика**
   - Логика расчета цен, подсчета налогов, обработки заказов должна быть написана без привязки к используемому фреймворку. Например, можно создать отдельные классы и модули, которые отвечают за эти задачи.

2. **Репозитории**
   - Репозитории данных (доступ к базе данных) могут использовать интерфейсы, чтобы их реализация могла быть легко изменена. Например:
     ```php
     interface UserRepositoryInterface {
         public function findById(int $id): User;
         public function save(User $user): void;
     }
     ```

3. **Тестирование**
   - Юнит-тесты бизнес-логики не должны зависеть от фреймворка:
     ```php
     public function testCalculateTax() {
         $calculator = new TaxCalculator();
         $result = $calculator->calculate(100, 0.15);
         $this->assertEquals(15, $result);
     }
     ```

4. **API-слой**
   - Реализация REST API или GraphQL может быть построена через интерфейсы, чтобы её можно было подключить к разным фреймворкам или заменить.

---

### **Как разработать framework agnostic приложение?**

1. **Начать с модели домена (DDD)**
   - Использовать концепцию **Domain-Driven Design**, чтобы сосредоточиться на бизнес-логике и изолировать её от технической инфраструктуры.

2. **Использовать паттерн "портов и адаптеров" (Hexagonal Architecture)**
   - Архитектурный стиль, который помогает отделить ядро приложения от взаимодействия с внешними системами (например, базами данных, HTTP-запросами).

3. **Внедрение зависимостей (Dependency Injection)**
   - Инструмент для передачи зависимостей в компоненты, чтобы не привязываться к конкретным реализациям.

4. **Реализация API через абстракции**
   - Для обработки запросов и ответов можно использовать абстрактные интерфейсы, которые затем связываются с конкретным фреймворком.

5. **Автономное тестирование**
   - Каждый модуль должен быть тестируем изолированно, без необходимости запускать весь фреймворк.

---

### **Пример: Framework Agnostic на PHP**

#### **Бизнес-логика**
```php
class TaxCalculator {
    public function calculate(float $amount, float $rate): float {
        return $amount * $rate;
    }
}
```

#### **Интерфейс репозитория**
```php
interface ProductRepositoryInterface {
    public function findById(int $id): Product;
    public function save(Product $product): void;
}
```

#### **Использование в фреймворке (например, Symfony или Laravel)**
```php
class ProductController {
    private ProductRepositoryInterface $productRepository;

    public function __construct(ProductRepositoryInterface $productRepository) {
        $this->productRepository = $productRepository;
    }

    public function show(int $id) {
        $product = $this->productRepository->findById($id);
        return response()->json($product);
    }
}
```

#### **Тестирование бизнес-логики**
```php
use PHPUnit\Framework\TestCase;

class TaxCalculatorTest extends TestCase {
    public function testCalculate() {
        $calculator = new TaxCalculator();
        $this->assertEquals(15, $calculator->calculate(100, 0.15));
    }
}
```

---

### **Заключение**

**Framework agnostic** подход делает код более гибким, переносимым и независимым от конкретных технологий. Это особенно важно для крупных и долгоживущих проектов, где фреймворки могут устаревать или требовать значительных изменений. Однако этот подход требует дополнительных усилий и глубокого понимания архитектуры приложения, что делает его подходящим для опытных команд, работающих с комплексными системами.