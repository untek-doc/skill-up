Алгоритмы сортировки — это класс методов для упорядочивания данных в массиве или списке. Существует множество алгоритмов сортировки, различающихся по времени выполнения, сложности реализации и используемым ресурсам. Важные параметры, по которым оцениваются алгоритмы сортировки, включают их **временную сложность**, **пространственную сложность**, а также стабильность (способность сохранять относительный порядок одинаковых элементов).

### Основные алгоритмы сортировки:

1. **Пузырьковая сортировка (Bubble Sort)**

   - **Описание**: Повторяющиеся проходы по массиву, при которых соседние элементы сравниваются и меняются местами, если они расположены в неправильном порядке.
   - **Время выполнения**: 
     - Худший случай: O(n²)
     - Средний случай: O(n²)
     - Лучший случай: O(n) (если массив уже отсортирован)
   - **Пространственная сложность**: O(1)
   - **Стабильность**: Да
   - **Пример**:
     ```php
     function bubbleSort($array) {
         $n = count($array);
         for ($i = 0; $i < $n; $i++) {
             for ($j = 0; $j < $n - 1 - $i; $j++) {
                 if ($array[$j] > $array[$j + 1]) {
                     // Меняем элементы местами
                     $temp = $array[$j];
                     $array[$j] = $array[$j + 1];
                     $array[$j + 1] = $temp;
                 }
             }
         }
         return $array;
     }
     ```

2. **Сортировка выбором (Selection Sort)**

   - **Описание**: На каждой итерации выбирается минимальный элемент из оставшихся и меняется местами с первым неотсортированным элементом.
   - **Время выполнения**: O(n²) в худшем, среднем и лучшем случаях.
   - **Пространственная сложность**: O(1)
   - **Стабильность**: Нет
   - **Пример**:
     ```php
     function selectionSort($array) {
         $n = count($array);
         for ($i = 0; $i < $n - 1; $i++) {
             $minIndex = $i;
             for ($j = $i + 1; $j < $n; $j++) {
                 if ($array[$j] < $array[$minIndex]) {
                     $minIndex = $j;
                 }
             }
             if ($minIndex != $i) {
                 $temp = $array[$i];
                 $array[$i] = $array[$minIndex];
                 $array[$minIndex] = $temp;
             }
         }
         return $array;
     }
     ```

3. **Сортировка вставками (Insertion Sort)**

   - **Описание**: Элементы по одному вставляются в правильное положение в отсортированной части массива.
   - **Время выполнения**: 
     - Худший случай: O(n²)
     - Средний случай: O(n²)
     - Лучший случай: O(n) (если массив уже отсортирован)
   - **Пространственная сложность**: O(1)
   - **Стабильность**: Да
   - **Пример**:
     ```php
     function insertionSort($array) {
         $n = count($array);
         for ($i = 1; $i < $n; $i++) {
             $key = $array[$i];
             $j = $i - 1;
             while ($j >= 0 && $array[$j] > $key) {
                 $array[$j + 1] = $array[$j];
                 $j--;
             }
             $array[$j + 1] = $key;
         }
         return $array;
     }
     ```

4. **Быстрая сортировка (Quick Sort)**

   - **Описание**: Рекурсивный алгоритм, который выбирает опорный элемент и делит массив на две части: элементы, меньшие опорного, и элементы, большие опорного. Затем сортирует эти части.
   - **Время выполнения**:
     - Худший случай: O(n²) (если массив уже отсортирован или элементы одинаковы)
     - Средний случай: O(n log n)
     - Лучший случай: O(n log n)
   - **Пространственная сложность**: O(log n) — O(n) в зависимости от реализации.
   - **Стабильность**: Нет
   - **Пример**:
     ```php
     function quickSort($array) {
         if (count($array) < 2) {
             return $array;
         }
         
         $left = $right = array();
         $pivot = $array[0];
         
         for ($i = 1; $i < count($array); $i++) {
             if ($array[$i] < $pivot) {
                 $left[] = $array[$i];
             } else {
                 $right[] = $array[$i];
             }
         }
         
         return array_merge(quickSort($left), array($pivot), quickSort($right));
     }
     ```

5. **Сортировка слиянием (Merge Sort)**

   - **Описание**: Делит массив на две части, рекурсивно сортирует обе части, затем объединяет их в один отсортированный массив.
   - **Время выполнения**: O(n log n) в худшем, среднем и лучшем случаях.
   - **Пространственная сложность**: O(n) (требуется дополнительная память для хранения результатов слияния)
   - **Стабильность**: Да
   - **Пример**:
     ```php
     function mergeSort($array) {
         if (count($array) <= 1) {
             return $array;
         }
         
         $middle = floor(count($array) / 2);
         $left = array_slice($array, 0, $middle);
         $right = array_slice($array, $middle);
         
         $left = mergeSort($left);
         $right = mergeSort($right);
         
         return merge($left, $right);
     }
     
     function merge($left, $right) {
         $result = array();
         $i = $j = 0;
         
         while ($i < count($left) && $j < count($right)) {
             if ($left[$i] <= $right[$j]) {
                 $result[] = $left[$i];
                 $i++;
             } else {
                 $result[] = $right[$j];
                 $j++;
             }
         }
         
         return array_merge($result, array_slice($left, $i), array_slice($right, $j));
     }
     ```

6. **Сортировка подсчётом (Counting Sort)**

   - **Описание**: Используется для сортировки целых чисел, ключи которых известны и не выходят за определённый диапазон. Алгоритм подсчитывает количество вхождений каждого числа и затем восстанавливает отсортированный массив.
   - **Время выполнения**: O(n + k), где `n` — размер массива, а `k` — диапазон ключей.
   - **Пространственная сложность**: O(k)
   - **Стабильность**: Да
   - **Пример**:
     ```php
     function countingSort($array, $maxValue) {
         $count = array_fill(0, $maxValue + 1, 0);
         $sortedArray = array();
         
         foreach ($array as $num) {
             $count[$num]++;
         }
         
         for ($i = 0; $i <= $maxValue; $i++) {
             while ($count[$i]-- > 0) {
                 $sortedArray[] = $i;
             }
         }
         
         return $sortedArray;
     }
     ```

### Сравнение алгоритмов сортировки:

| Алгоритм             | Время (худшее) | Время (среднее) | Время (лучшее) | Пространство | Стабильность |
|----------------------|----------------|-----------------|----------------|--------------|--------------|
| Пузырьковая сортировка| O(n²)          | O(n²)           | O(n)           | O(1)         | Да           |
| Сортировка выбором    | O(n²)          | O(n²)           | O(n²)          | O(1)         | Нет          |
| Сортировка вставками  | O(n²)          | O(n²)           | O(n)           | O(1)         | Да           |
| Быстрая сортировка    | O(n²)          | O(n log n)      | O(n log n)     | O(log n)     | Нет          |
| Сортировка слиянием   | O(n log n)     | O(n log n)      | O(n log n)     | O(n)         | Да           |
| Сортировка подсчётом  | O(n + k)       | O(n + k)        | O(n + k)       | O(k)         | Да           |
